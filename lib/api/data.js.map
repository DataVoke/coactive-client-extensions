{"version":3,"sources":["../../src/api/data.js"],"names":["api","loadExtension","data","recordToObject","record","attachNativeRecord","includeHiddenColumns","ui","getDefaultForm","selectedRecord","object","gridValues","raw","gridColumns","apiRef","parent","Values","forEach","item","getVal","Type","UID","property","columnProperty","IsHidden","Definition","Name","value","_record","recordsToObjects","form","records","map","noop","objectToRecord","options","callback","actions","execute","dvCore","NewRecord","result","success","Error","actionMessage","Object","keys","key","objKeys","i","k","lookForPropertyName","toLowerCase","recordProperty","find","expr","Array","isArray","replace","SetValue","propertyId","PropertyID","expression","length","objectsToRecords","objects","objectToNewRecord","setValuesForRecord","index","indexOf","objectsToForm","progressBar","progressIncrement","useOrdinalMatching","makeDataStateDirty","factory","View","objectCount","Promise","resolve","batchCount","Math","ceil","app","dv","mvc","setBulkInsert","maxValue","importBatchRecords","importData","importForm","lowerLimit","upperLimit","il","row","importLoadRecord","createRecord","values","clientRecord","Record","_State","types","EntityStates","Unmodified","addRecord","columnCounter","maxDataColumns","contextGridColumnValues","j","jl","col","primaryRecordType","CodePropertyID","gridValue","dynamicValue","Value","dynamicValueEdit","hasOwnProperty","valueToImport","decodeURIComponent","ex","console","log","gridValueToMerge","displayProperties","getText","setText","e","batchIdx","processChunk","min","progressMessage","setTimeout","then","columnArrayToObjects","columns","includeColumnUIDs","column","some","uid","header","treeItem","summaryText","recordArrayToObjects","groupItemArrayToObjects","groupItems","sort","groupItemsSorter","groupItem","children","getAllChildRecords","formToObjects","grouped","hierarchical","gridController","mvcColumns","gridColumn","filter","Boolean","groupTree","expandCollapseAllGroups","boundArray","objs","getSortedRecords","a","b","getEndpointResult","endpointName","inputParameters","reject","connection","call","error"],"mappings":"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","sourcesContent":["/**\n * Custom Action: Extend api.data\n * Extends the api.data namespace with additional helper functions.\n * Dependencies:\n *    api.loadExtension\n *    api.ui\n */\napi.loadExtension(\"api.data\", () => {\n    if (!api.data.recordToObject) {\n        api.data.recordToObject = (record, attachNativeRecord = false, includeHiddenColumns = false) => {\n            if (!record)\n                record = api.ui.getDefaultForm().selectedRecord;\n            const object = {};\n            if (!record.gridValues) {\n                record = record.raw;\n            }\n            const gridColumns = record.apiRef.parent.raw.gridColumns;\n            record.gridValues.Values.forEach(item => {\n                if (includeHiddenColumns || !gridColumns.getVal({ Type: \"Column\", UID: item.property.UID}).columnProperty.IsHidden) {\n                    object[item.property.Definition.Name] = item.value;\n                    object[item.property.Name] = item.value;\n                }\n            });\n            if (attachNativeRecord) {\n                object._record = record;\n            }\n            return object;\n        };\n    }\n\n    if (!api.data.recordsToObjects) {\n        api.data.recordsToObjects = (form, attachNativeRecord = false, includeHiddenColumns = false) => {\n            if (!form)\n                form = api.ui.getDefaultForm();\n            return form.records.Values.map(item => api.data.recordToObject(item, attachNativeRecord, includeHiddenColumns));\n        };\n    }\n\n    let noop = function() {};\n\n    if (!api.data.objectToRecord) {\n        api.data.objectToRecord = (object, options, callback = noop) => {\n            let { form, record, map } = options;\n            if (record) {\n                // If a record was provided, use its form\n                form = record.parent;\n            }\n            if (!form) {\n                // If no form was provided or detected, use the default one\n                form = api.ui.getDefaultForm();\n            }\n            if (!record) {\n                // If no record was provided, create one on the identified form\n                api.actions.execute(form, api.actions.dvCore.NewRecord, {}, result => {\n                    if (result.success) {\n                        record = form.apiRef.selectedRecord.raw;\n                    } else {\n                        throw new Error(result.actionMessage);\n                    }\n                });\n            }\n            if (!map) {\n                // If no map was provided, assume keys/property names match between object and record\n                map = {};\n                Object.keys(object).forEach(key => map[key] = key);\n            }\n            // Transfer the values from the object to the record\n            let objKeys = Object.keys(map);\n            for (let i = 0, k = objKeys.length; i < k; i++) {\n                let key = objKeys[i];\n                const lookForPropertyName = map[key].toLowerCase();\n                const recordProperty = record.gridValues.Values.find(item => {\n                    return item.property.Definition.Name.toLowerCase() === lookForPropertyName || item.property.Name.toLowerCase() === lookForPropertyName;\n                });\n                if (recordProperty) {\n                    //If the key on the incoming object is an array, use it's first element\n                    let expr = Array.isArray(object[key]) ? object[key][0] : object[key];\n                    //If we have an invalid expression, add an escape character\n                    expr = expr\n                        .replace(/'/g, \"''\")\n                        .replace(/}/g, \"' + Char(125) + '\");\n                    api.actions.execute(form, api.actions.dvCore.SetValue, {\n                        propertyId: recordProperty.property.PropertyID,\n                        expression: `'${expr}'`\n                    }, result => {\n                        if (!result.success) {\n                            throw new Error(result.actionMessage);\n                        }\n                    });\n                }\n            }\n            if (!!callback) {\n                callback();\n            }\n        };\n    }\n\n    if (!api.data.objectsToRecords) {\n        api.data.objectsToRecords = (objects, options) => {\n            objects.forEach(item => api.data.objectToRecord(item, options));\n        };\n    }\n\n    if (!api.data.objectToNewRecord) {\n        api.data.objectToNewRecord = (object, options, callback = noop) => {\n            let { form, map } = options;\n            let record;\n            if (!form) {\n                // If no form was provided or detected, use the default one\n                form = api.ui.getDefaultForm();\n            }\n            // Create new record on the identified form\n            api.actions.execute(form, api.actions.dvCore.NewRecord, {}, result => {\n                if (!result.success) {\n                    throw new Error(result.actionMessage);\n                }\n                else {\n                    record = form.apiRef.selectedRecord.raw;\n                    if (!map) {\n                        // If no map was provided, assume keys/property names match between object and record\n                        map = {};\n                        Object.keys(object).forEach(key => object[key] = key);\n                    }\n                    // Transfer the values from the object to the record\n                    let keys = Object.keys(map);\n                    (function setValuesForRecord (index) {\n                        let key = keys[index];\n                        const lookForPropertyName = map[key].toLowerCase();\n                        const recordProperty = record.gridValues.Values.find(item => {\n                            return item.property.Definition.Name.toLowerCase() === lookForPropertyName || item.property.Name.toLowerCase() === lookForPropertyName;\n                        });\n                        if (recordProperty) {\n                            //If the key on the incoming object is an array, use it's first element\n                            let expr = Array.isArray(object[key]) ? object[key][0] : object[key];\n                            //If we have an invalid expression, add an escape character\n                            if (expr != null && expr.indexOf(\"'\") > -1) {\n                                expr = expr.replace(/'/g, \"''\");\n                            }\n                            api.actions.execute(form, api.actions.dvCore.SetValue, {\n                                propertyId: recordProperty.property.PropertyID,\n                                expression: `'${expr}'`\n                            }, result => {\n                                if (!result.success) {\n                                    throw new Error(result.actionMessage);\n                                }\n                                if (index === keys.length - 1) {\n                                    callback();\n                                }\n                                else {\n                                    index++;\n                                    setValuesForRecord(index);\n                                }\n                            });\n                        }\n                    })(0);\n                }\n            });\n        };\n    }\n\n    if (!api.data.objectsToForm) {\n        api.data.objectsToForm = ({\n            objects,\n            form,\n            progressBar,\n            progressIncrement = 50,\n            useOrdinalMatching = false,\n            makeDataStateDirty = true,\n        }) => {\n            if (!Array.isArray(objects)) {\n                throw new Error(\"The objects parameter must be an array of objects.\");\n            }\n\n            // Make sure we've got a raw form (may be an API reference)\n            if (form instanceof api.factory.View) {\n                form = form.raw;\n            }\n            const objectCount = objects.length;\n\n            return new Promise((resolve) => {\n                const batchCount = Math.ceil(objectCount / progressIncrement);\n\n                // Prevent UI updates while adding records\n                app.dv.mvc.setBulkInsert(form, true);\n\n                if (progressBar) {\n                    progressBar.maxValue = objectCount;\n                    progressBar.value = 0;\n                }\n\n                const importBatchRecords = (importData, importForm, lowerLimit, upperLimit) => {\n                    return new Promise((resolve) => {\n                        for (let i = lowerLimit, il = upperLimit; i < il; i++) {\n                            const row = importData[i];\n                            const importLoadRecord = app.dv.mvc.createRecord(importForm, Object.values(row)[0]);\n                            if (!makeDataStateDirty) {\n                                // Set data state to not dirty if so indicated\n                                importLoadRecord.clientRecord.Record._State = app.dv.types.EntityStates.Unmodified;\n                            }\n                            app.dv.mvc.addRecord(importForm, importLoadRecord, null);\n                            if (importLoadRecord != null) {\n                                // whether this is a new or found record, we now need to merge it.\n                                let columnCounter = 1;\n                                const maxDataColumns = row.length;\n                                const contextGridColumnValues = importForm.gridColumns.Values;\n\n                                for (let j = 0, jl = contextGridColumnValues.length; j < jl; j++) {\n                                    try {\n                                        // if we are out of columns in our data, import no more.\n                                        if (columnCounter >= maxDataColumns) { break; }\n\n                                        // get the current column\n                                        const col = contextGridColumnValues[j];\n\n                                        if (importForm.primaryRecordType.Definition.CodePropertyID !== null && col.property.UID === importForm.primaryRecordType.Definition.CodePropertyID.UID) {\n                                            if (!makeDataStateDirty) {\n                                                // Set data state to not dirty if so indicated\n                                                const gridValue = importLoadRecord.gridValues.getVal(importForm.primaryRecordType.Definition.CodePropertyID);\n                                                gridValue.dynamicValue._State = app.dv.types.EntityStates.Unmodified;\n                                                gridValue.dynamicValue.Value = gridValue.dynamicValueEdit.Value;\n                                                gridValue.dynamicValueEdit = null;\n                                            }\n                                            // skip the record code property, it was either used to create the record or find it.\n                                            continue;\n                                        }\n\n                                        if (useOrdinalMatching && col.columnProperty.IsHidden == true) {\n                                            // if the column is hidden, it shouldn't be touched by the import.\n                                            continue;\n                                        }\n\n                                        if (row.hasOwnProperty(col.property.Name)) {\n                                            // get the import value by name or position.\n                                            let valueToImport = useOrdinalMatching ?\n                                                Object.values(row)[columnCounter] :\n                                                row[col.property.Name];\n                                            try {\n                                                //Try to decode URI the value\n                                                valueToImport = decodeURIComponent(valueToImport);\n                                            }\n                                            catch(ex) {\n                                                //There was an error decoding the data\n                                                console.log(`An error occurred while performing a decodeURI on row: ${i} column ${columnCounter}`);\n                                            }\n                                            columnCounter++;\n\n                                            // if the text value is \"null\", then assume that it really is a null value.\n                                            if (valueToImport.toLowerCase() == \"null\") { valueToImport = null; }\n                                            if ((valueToImport == null || valueToImport == \"\")) {\n                                                // if they are trying to load an empty value into a new record, skip this.\n                                                continue;\n                                            }\n\n                                            // get the grid value for this column property in this record.\n                                            const gridValueToMerge = importLoadRecord.gridValues.getVal(col.property.PropertyID);\n\n                                            if (gridValueToMerge.displayProperties.getText() !== valueToImport) {\n                                                // update/merge the value.\n                                                gridValueToMerge.displayProperties.setText(valueToImport);\n                                                if (!makeDataStateDirty) {\n                                                    // Set data state to not dirty if so indicated\n                                                    gridValueToMerge.dynamicValue._State = app.dv.types.EntityStates.Unmodified;\n                                                    gridValueToMerge.dynamicValue.Value = gridValueToMerge.dynamicValueEdit.Value;\n                                                    gridValueToMerge.dynamicValueEdit = null;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    catch (e) {\n                                        app.dv.mvc.setBulkInsert(importForm, false);\n                                    }\n                                }\n                                resolve();\n                            }\n                        }\n                    });\n                }\n\n                let batchIdx = 0;\n                const processChunk = () => {\n\n                    if (batchIdx === batchCount) {\n                        // stop bulk insert on the MVC and show the records that were imported in the MVC grid...\n                        app.dv.mvc.setBulkInsert(form, false);\n                        resolve();\n                        return;\n                    }\n\n                    const lowerLimit = batchIdx * progressIncrement;\n                    const upperLimit = Math.min(lowerLimit + progressIncrement, objectCount);\n                    // if (upperLimit > objectCount) { upperLimit = objectCount; }\n                    if (progressBar) {\n                        progressBar.value = upperLimit;\n                        progressBar.progressMessage = `${upperLimit} / ${objectCount}`;\n                    }\n\n                    setTimeout (() => {\n                        importBatchRecords(objects, form, lowerLimit, upperLimit).then(() => {\n                            batchIdx++;\n                            processChunk();\n                        });\n                    }, 50);\n                }\n\n                processChunk();\n            });\n        };\n    }\n\n    if (!api.data.columnArrayToObjects) {\n        api.data.columnArrayToObjects = (columns, includeColumnUIDs) => {\n            const object = {};\n            (columns||[]).forEach(column => {\n                if (column && column.property && column.property.Definition && column.property.Definition.Name) {\n                    if (!includeColumnUIDs || includeColumnUIDs.some(uid => uid === column.property.UID)) {\n                        object[column.property.Definition.Name] = column.value;\n                    }\n                } else if (column && column.header && column.treeItem) {\n                    object[\"\"] = `${column.treeItem.value.value} - ${column.treeItem.summaryText()}`;\n                }\n            });\n            return object;\n        };\n    }\n\n    if (!api.data.recordArrayToObjects) {\n        api.data.recordArrayToObjects = (records, includeColumnUIDs) => {\n            return (records||[]).map(record => api.data.columnArrayToObjects(record, includeColumnUIDs));\n        };\n    }\n\n    if (!api.data.groupItemArrayToObjects) {\n        api.data.groupItemArrayToObjects = (groupItems, includeColumnUIDs) => {\n            return (groupItems||[]).sort(api.data.groupItemsSorter).map(groupItem => ({\n                [`${groupItem.value.property.Definition.Name}`]: groupItem.value.value,\n                records: groupItem.children && groupItem.children.length ?\n                         api.data.groupItemArrayToObjects(groupItem.children, includeColumnUIDs) :\n                         api.data.recordArrayToObjects(groupItem.getAllChildRecords(), includeColumnUIDs),\n            }));\n        };\n    }\n\n    if (!api.data.formToObjects) {\n        api.data.formToObjects = ({\n            form = api.ui.getDefaultForm(),\n            includeHiddenColumns = false,\n            grouped = true,\n            hierarchical = false,\n        }) => {\n            // Make sure we've got a raw form (may be an API reference)\n            if (form instanceof api.factory.View) {\n                form = form.raw;\n            }\n            const gridController = form.gridController;\n            const includeColumnUIDs =  gridController.mvcColumns.map(gridColumn => {\n                if (includeHiddenColumns || !gridColumn.columnProperty.IsHidden) {\n                    return gridColumn.property.UID;\n                }\n            }).filter(gridColumn => Boolean(gridColumn));\n            if (hierarchical) {\n                return api.data.groupItemArrayToObjects(gridController.groupTree, includeColumnUIDs);\n            } else if (grouped) {\n                //  The boundArray property only includes visible rows, so we need to expand all groups first\n                gridController.expandCollapseAllGroups(true);\n                return api.data.recordArrayToObjects(gridController.boundArray.objs, includeColumnUIDs);\n            } else {\n                //  The getSortedRecords method only includes visible rows, so we need to expand all groups first\n                gridController.expandCollapseAllGroups(true);\n                return api.data.recordArrayToObjects(gridController.getSortedRecords().map(record => record.gridValues.Values), includeColumnUIDs);\n            }\n        };\n    }\n\n    if (!api.data.groupItemsSorter) {\n        api.data.groupItemsSorter = (a, b) => {\n            if (a.value.value > b.value.value) {\n                return 1;\n            }\n            if (a.value.value < b.value.value) {\n                return -1;\n            }\n            return 0;\n        };\n    }\n\n    if (!api.data.getEndpointResult) {\n        api.data.getEndpointResult = async (endpointName, inputParameters = {}) => {\n            try {\n                return new Promise((resolve, reject) => {\n                    if (endpointName) {\n                        // const input = eval(`(function() { return ${inputParameters}; })()`);\n                        app.connection.call(\"Custom\", endpointName, inputParameters, (result, error) => {\n                            resolve(result);\n                        });\n                    } else {\n                        reject(\"There is no endpoint specified.\");\n                    }\n                });\n            } catch (exc) {\n                throw exc;\n            }\n        }\n    }\n});\n"],"file":"data.js"}